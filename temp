STATIC_LOCATIONS = ["https://consumer-api.development.dev.woltapi.com/home-assignment-api/v1/venues/home-assignment-venue-helsinki/static",
                    "https://consumer-api.development.dev.woltapi.com/home-assignment-api/v1/venues/home-assignment-venue-stockholm/static",
                    "https://consumer-api.development.dev.woltapi.com/home-assignment-api/v1/venues/home-assignment-venue-berlin/static",
                    "https://consumer-api.development.dev.woltapi.com/home-assignment-api/v1/venues/home-assignment-venue-tokyo/static"
                    ]

# DYNAMIC_LOCATIONS = [
#     "https://consumer-api.development.dev.woltapi.com/home-assignment-api/v1/venues/home-assignment-venue-helsinki/dynamic",
#     "https://consumer-api.development.dev.woltapi.com/home-assignment-api/v1/venues/home-assignment-venue-stockholm/dynamic",
#     "https://consumer-api.development.dev.woltapi.com/home-assignment-api/v1/venues/home-assignment-venue-berlin/dynamic",
#     "https://consumer-api.development.dev.woltapi.com/home-assignment-api/v1/venues/home-assignment-venue-tokyo/dynamic"
# ]

BASE_URL = "https://consumer-api.development.dev.woltapi.com/home-assignment-api/v1/venues/"

ORDER_MIN = "order_minimum_no_surcharge"
BASE_PRICE = "base_price"
DISTANCE_RANGES = "distance_ranges"
import time
import requests
import logging
from typing import  Dict 
from enum import Enum

#CUSTOM MODULES
from const import STATIC_LOCATIONS, BASE_URL, ORDER_MIN, BASE_PRICE, DISTANCE_RANGES

class StaticLocation:
    def __str__(self):
        return f"Static data:\n{str(self.locations)}"

    def __init__(self):
        self.locations: Dict[str, Dict[str, float]] = {}
        for _url in STATIC_LOCATIONS:
            try:
                resp_static: requests.Response = requests.get(url=_url)
                if resp_static.status_code != 200:
                    logging.error(f"Error requesting static API at {_url}. Status code: {resp_static.status_code}, Reason: {resp_static.reason}")
                    continue
                venue_name = _url.split("/")[-2]
                static_data = resp_static.json()
                coordinates = static_data["venue_raw"]["location"]["coordinates"]
                self.set(venue_name, coordinates[0], coordinates[1])
            except Exception as e:
                logging.error(f"Request failed for {_url}: {e}")

    def set(self, venue_name: str, longitude: float, latitude: float):
        if venue_name not in self.locations:
            self.locations[venue_name] = {}
        coordinates = [longitude, latitude]
        self.locations[venue_name] = coordinates

    async def get_coordinates(self, venue_name: str) -> Dict[str, float]:
        if self.locations.get(venue_name):
            raise Exception(f"Static Location not found in cache: {venue_name}")
        return self.locations[venue_name]

class DynamicLocation:

    @staticmethod
    async def get(venue_name) -> Dict:
        """
        Fetch and parse dynamic data.
        """
        resp = await self.fetch(venue_name)
            
        dynamic_data = resp.json()
        delivery_specs = dynamic_data["venue_raw"]["delivery_specs"]
        delivery_pricing = delivery_specs["delivery_pricing"]
        
        ret: Dict = {}
        ret[ORDER_MIN] = delivery_specs[ORDER_MIN] # int
        ret[BASE_PRICE] = delivery_pricing[BASE_PRICE] # int
        ret[DISTANCE_RANGES] = delivery_pricing[DISTANCE_RANGES]
        ''' "distance_ranges":[{"min":0,"max":500,"a":0,"b":0.0,"flag":null},{"min":500,"max":1000,"a":100,"b":0.0,"flag":null},
        {"min":1000,"max":1500,"a":200,"b":0.0,"flag":null},{"min":1500,"max":2000,"a":200,"b":1.0,"flag":null},{"min":2000,"max":0,"a":0,"b":0.0,"flag":null}] '''
        return ret
            
    @staticmethod
    async def fetch(venue_name: str) -> Dict:
        """
        Fetch dynamic data from the Wolt venue API.
        """
        _url = f"{BASE_URL}/{venue_name}/dynamic"
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(_url) as resp:
                    if resp.status != 200:
                        raise Exception(f"Error requesting dynamic API, response: {resp.status}\n{await resp.text()}")
                    return await resp.json()
        except Exception as e:
            raise Exception(f"Failed request to {_url}: {e}")
    

# curl http://localhost:8000/api/v1/delivery-order-price?venue_slug=home-assignment-venue-helsinki&cart_value=1000&user_lat=60.17094&user_lon=24.93087

import uvicorn
import requests
import json
import sys
from fastapi import FastAPI, Query, HTTPException
import logging

# CUSTOM MODULES
from data import StaticLocation, DynamicLocation
from const import ORDER_MIN, BASE_PRICE, DISTANCE_RANGES

# GLOBALS
app = FastAPI()
static_data: StaticLocation
logging.basicConfig(
    level=1,
    handlers=[
        logging.FileHandler("logger", mode="w"),
        logging.StreamHandler()
    ]
)

class CustomerInput:
    def __init__(self, _venue_slug: str, _cart_value: int, _lon: float, _lat: float):
        self.venue_slug = _venue_slug
        self.cart_value = _cart_value
        self.lon = _lon
        self.lat = _lat

class Order:

    @staticmethod
    def haversine(lon1: float, lat1: float, lon2: float, lat2: float) -> float:
        """
        Get the distance between two coordinates.
        """
        lon1, lat1, lon2, lat2 = map(radians, (lon1, lat1, lon2, lat2))

        dlon = lon2 - lon1
        dlat = lat2 - lat1
        a = sin(dlat / 2)**2 + cos(lat1) * cos(lat2) * sin(dlon / 2)**2
        c = 2 * asin(sqrt(a))
        radius_km = 6371
        return c * radius_km

    @staticmethod
    def calculatePrice(customer_input: CustomerInput, dynamic_data: DynamicLocation, delivery_distance: float) -> dict:
        distance_ranges = dynamic_data[DISTANCE_RANGES]
        order_minimum_no_surcharge = dynamic_data[ORDER_MIN]
        
        # calculate delivery fee
        delivery_fee = dynamic_data[BASE_PRICE]
        for range in distance_ranges:
            if range["max"] == 0 and delivery_distance >= range["min"]:
                raise Exception(f"Delivery not possible for this distance {delivery_distance}")
            if range["min"] <= delivery_distance < range["max"]:
                delivery_fee += range["a"] + round(range["b"] * delivery_distance / 10)
                break
        else:
            raise Exception(f"Delivery not possible for this distance {delivery_distance}")

        small_order_surcharge = max(0, order_minimum_no_surcharge - cart_value)
        total_price = customer_input.cart_value + small_order_surcharge + delivery_fee

        result = {
            "total_price": total_price,
            "small_order_surcharge": small_order_surcharge,
            "cart_value": customer_input.cart_value,
            "delivery": {
                "fee": fee,
                "distance": delivery_distance,
            }
        }
        return result

@app.get("/api/v1/delivery-order-price")
async def get_delivery_order_price(
    venue_slug: str = Query(..., description="The unique identifier for the venue"),
    cart_value: int = Query(..., description="The shopping cart total value"),
    user_lat: float = Query(..., description="The latitude of the user's location"),
    user_lon: float = Query(..., description="The longitude of the user's location"),
    ):
    customer_input = CustomerInput(venue_slug, cart_value, user_lat, user_lon)
    # fetch static and dynamic venue data
    try:
        venue_coordinates = await static_data.get_coordinates(venue_slug)
    except Exception as e:
        logging.critical(f"Error fetching coordinates: {e}")
        raise HTTPException(status_code=500, detail="Error fetching venue coordinates")
    try:
        dynamic_data = await DynamicLocation.get(venue_slug)
    except:
        logging.critical(f"Error fetching dynamic venue data: {e}")
        raise HTTPException(status_code=500, detail="Error fetching venue data")
    try:
        delivery_distance = Order.haversine(user_lon, user_lat, venue_coordinates[0], venue_coordinates[1])
        Order.calculatePrice(customer_input, dynamic_data, delivery_distance)
    except:
        logging.error(f"The delivery address is too far from the venue{e}")
        raise HTTPException(status_code=422, detail="The delivery address is too far from the venue")

def main():
    static_data = StaticLocation()
    if len(static_data.locations) == 0:
        logger.critical("No static locations found")
    uvicorn.run(app, host="0.0.0.0", port=8000)

if __name__ == "__main__":
    main()
